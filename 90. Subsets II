// performance wise good "Avoids StackOverflowError and recursive overhead."
//iterative

class Solution {
    private void help(int[] nums , int idx , List<List<Integer>> res , List<Integer> cur){
        if(idx == nums.length) {
            res.add(new ArrayList<>(cur));
            return ;
        }
        cur.add(nums[idx]);
        help(nums, idx+1 , res , cur);
        cur.remove(cur.size()-1);
        int i = idx+1 ;
        while(i < nums.length && nums[i] == nums[idx]) i++ ;
        help(nums , i , res , cur);
        
    }
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        help(nums , 0 , res , new ArrayList<>());
        return res ;
    }
}

// best for interview "Most readable and demonstrates standard backtracking patterns."
//recursive(loop)

class Solution {
    private void help(int idx , int[] nums , List<Integer> l , List<List<Integer>> ans){
        ans.add(new ArrayList<>(l));
        for(int i = idx ; i < nums.length ; i++){
            if(i != idx && nums[i] == nums[i-1]) continue ;
            l.add(nums[i]);
            help(i+1,nums,l,ans);
            l.remove(l.size()-1);
        }
    }
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        help(0,nums,new ArrayList<>(),ans);
        return ans ;
    }
}
